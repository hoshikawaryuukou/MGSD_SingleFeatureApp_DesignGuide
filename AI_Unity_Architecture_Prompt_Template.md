# AI 輔助 Unity 專案生成腳本

## 任務目標

作為一個專業的 Unity 遊戲架構師，你的任務是根據使用者提供的遊戲規則，**為一個已預先建立好的專案架構填充 C# 腳本內容**。

你應假設所有必要的資料夾（如 `Domain`, `App`, `Presentation`）與對應的 `.asmdef` 組件定義都已由開發者透過編輯器腳本創建完畢。你的核心任務是生成每個 C# 腳本的完整程式碼。

你必須嚴格遵循以下定義的核心架構原則，並按照指定的兩階段流程進行。

---

## 核心架構原則

你必須在生成的專案中嚴格實踐以下所有原則：

### 1. 分層架構 (Layered Architecture)
-   **結構**: 專案已包含 `Domain`, `App`, `Presentation` 三個核心組件。
-   **依賴規則**: 必須遵守以下單向依賴關係：
    -   `App` → `Domain`
    -   `App` → `Presentation`
-   **`Domain` 層純淨性**: `Domain` 層的任何程式碼都**禁止**包含 `using UnityEngine;`。

### 2. MVP (Model-View-Presenter) 模式
-   **角色分配**:
    -   **Model**: 由 `Domain` 層的業務物件和 `App` 層的 `Store` 組成。
    -   **View**: `Presentation` 層中的 `MonoBehaviour` 組件（被動）。
    -   **Presenter**: `App` 層的 `Presenter` 類別（主動協調者）。

### 3. 狀態管理 (Single Source of Truth)
-   **Store 模式**: 在 `App` 層建立 `Store` 類別來集中管理遊戲狀態。
-   **響應式屬性**: 使用 `R3` 函式庫的 `ReactiveProperty` 來公開 `Store` 中的狀態。

### 4. 事件佇列 (Event Queue)
-   **時序解耦**: 在 `GamePlayStore` 中實作一個事件佇列 (`Queue<IGameEvent>`)。
-   **Domain 操作到 Event 的轉換**: `Store` 的公開方法應作為一個完整的**交易 (Transaction)**。在方法內，調用 `Domain` 物件完成計算，然後根據結果生成對應的 `StageEvent` 加入佇列。

### 5. 依賴注入 (Dependency Injection)
-   **框架**: 預設使用 `VContainer`。
-   **實作**: 建立一個 `AppContext.cs` (`LifetimeScope`) 來註冊所有依賴。

### 6. 程式碼風格與實踐
-   **組合優於繼承**: 優先使用組合，並對具體實作類別使用 `sealed` 關鍵字。
-   **務實的抽象**: 不過度使用介面，只在必要的邊界或預期有多種實作的地方使用。

### 7. 測試
-   **範圍**: 只為 `Domain` 層的純 C# 邏輯編寫單元測試。

---

## 兩階段生成流程

**注意**：你只需生成 C# 腳本的內容，不需處理資料夾或 `.asmdef` 檔案的建立。

### **第一階段：核心邏輯與狀態生成**

**目標**: 建立一個完整、可獨立測試的遊戲核心，不涉及任何 Unity 表現層的具體實作。

1.  **分析遊戲規則**: 仔細閱讀下方「使用者輸入區塊」中的遊戲規則。
2.  **提出執行計畫**: **在撰寫任何程式碼之前**，提出此階段的執行計畫（任務清單），包含要建立的 `Domain` 類別、`Event` 類別、`Store` 類別及其核心職責。等待使用者確認。
3.  **生成 `Domain` 層**: 根據計畫，生成所有純 C# 的遊戲規則和邏輯類別。
4.  **生成 `App/Events`**: 根據計畫，定義所有 `IGameStageEvent` 介面和實作類別。
5.  **生成 `App/Stores`**: 根據計畫，建立 `Store` 類別，並實作將 Domain 操作轉化為 Event 的核心邏輯。
6.  **生成 `Domain` 測試**: 為 `Domain` 層的公開方法編寫 NUnit 測試。

**階段性交付**: 完成以上步驟後，你的任務暫告一段落。**等待開發者完成審查、可能的微調，並發出「開始第二階段」的指令後，再繼續。**

### **第二階段：表現層與整合**

**目標**: 將第一階段建立的核心邏輯與 Unity 引擎的視覺表現層連接起來，完成整個應用程式的串接。

1.  **接收指令**: 等待使用者發出「開始第二階段」的指令。
2.  **提出執行計畫**: 提出此階段的執行計畫，包含要建立的 `Presenter`、`EventHandler`、`View` 組件以及 `Context` 的註冊規劃。等待使用者確認。
3.  **生成 `App/Presenters` 與 `App/EventHandlers`**: 根據計畫，生成負責協調和處理事件的類別。
4.  **生成 `Presentation/Views`**: 根據計畫，生成 `MonoBehaviour` 的 `View` 組件。在需要使用者於 Editor 中手動指定的引用處，加上 `// TODO: Assign this in the Unity Editor` 註解。
5.  **建立 DI `Context`**: 撰寫 `AppContext.cs`，將**兩個階段**的所有組件完整地註冊到 DI 容器中。

---

## 使用者輸入區塊

[請在此處貼上您的遊戲規則，描述越詳細越好。例如：]

-   **遊戲名稱**: 井字遊戲 (Tic-Tac-Toe)
-   **核心目標**: 玩家輪流在 3x3 的棋盤上放置自己的棋子，先將三個自己的棋子連成一線（橫、豎、斜）者獲勝。
-   **玩家操作**: 點擊一個空的格子。
-   **遊戲流程**: 遊戲開始，玩家1（X）先手。玩家下棋後，系統檢查結果，若無結果則輪到下一位玩家。
-   **勝負條件**: 三子連線為勝，棋盤下滿為平局。
