# Unity Single Feature App 專案設計指南

## 設計動機

這套專案指南的誕生，源自於兩大核心驅動力：追求高效的**開發者體驗**，以及應對**AI協作開發**的新挑戰。

### 1. 追求實用與舒適的開發體驗

軟體架構從來沒有絕對的標準答案，只有在特定場景下的最適解。本指南提出的架構，是在探索了多種設計模式與架構風格後，沉澱下來的一套實踐結晶。

它的核心目標是**降低開發過程中的「心智負擔」**。開發者時常會困惑於「這段程式碼應該放哪裡？」，或在接手舊專案時，被混亂的結構搞得暈頭轉向。

這套架構提供了一套清晰、符合直覺的規則，讓開發者：
*   **快速定位**：能毫不費力地找到需要修改或閱讀的程式碼。
*   **專注當下**：在開發某個模組時，無需擔心對其他部分產生預期外的影響。
*   **減少決策疲勞**：明確的職責劃分，讓「程式碼該放哪」成為一個簡單的填空題，而非開放的申論題。

總之，這是一套以**實用性為導向**，致力於讓開發過程感覺**更舒服、更流暢**的設計。

### 2. 為 AI 協作打造的結構化框架

在確認這套架構對人類開發者友善的同時，其**清晰的規則和強制性的邊界**，恰好為 AI 協作提供了絕佳的基礎。

初見此架構，可能會覺得對於單一功能應用來說有些「過度設計」。然而，這個設計的另一個核心目標，是**引導 AI 在一個高品質的模式下進行開發，而非讓其失控地創造**。

AI 開發原型的潛力有目共睹，但其副作用也同樣令人困擾：
*   **巨型腳本（Monolithic Scripts）**：所有邏輯被塞進單一檔案，難以維護。
*   **混亂的職責劃分（Poor Separation of Concerns）**：專案結構不合理，僅僅是「能動」，卻無法作為穩定產品的基石。

本指南提供的是一個結構化的「軌道」，而非一張任其揮灑的「白紙」。透過強制 AI 遵循**單一職責原則**，能確保它產出的程式碼具備高可讀性、易維護性與可擴展性，將 AI 從一個「原型工具」，提升為一個能產出**專業、穩固程式碼**的可靠開發夥伴。


## 技術棧

| 函式庫          | 類別                | 用途與選擇理由                                                                                   |
| :-------------- | :------------------ | :----------------------------------------------------------------------------------------------- |
| **VContainer**  | 依賴注入 (DI)       | 輕量、高效能。用於解耦物件依賴，是整個架構的黏合劑。                                             |
| **UniTask**     | 非同步處理          | 提供 `async/await` 語法，取代協程，讓複雜的非同步流程程式碼更簡潔、易讀。                        |
| **R3**          | 響應式編程 (Rx)     | UniRx 的後繼者，新一代響應式函式庫，用於建立資料流，優雅地處理事件與資料綁定，特別適合 UI 更新。 |
| **MessagePipe** | 發布/訂閱 (Pub/Sub) | 高效能的事件匯流排，用於完全解耦的組件間通訊，避免不必要的直接引用。                             |

## 專案結構

```
Assets/
├── Res/                        # 美術、音效等非程式資源
├── Scripts/
│   ├── Runtime/                # 遊戲執行時的主要程式碼
│   │   ├── App/                # 應用層，流程控制與狀態管理
│   │   │   ├── Stores/         # 應用程式的狀態管理 (MVP 的 M)
│   │   │   └── Presenters/     # 應用程式的流程控制與視圖協調 (MVP 的 P)
│   │   ├── Contexts/           # DI 容器的設定與進入點
│   │   ├── Domain/             # 核心業務 logique，不依賴 Unity
│   │   ├── Infrastructures/    # 底層通用功能 (如 HTTP, Audio)
│   │   ├── Presentation/       # 視圖元件 (MVP 的 V)
│   │   ├── Services/           # 業務服務，連接 Domain 與外部
│   │   └── Shared/             # 跨模組共用的資料結構或工具
│   └── Tests/                  # 測試程式碼
│       └── Domain/             # 針對 Domain 層的單元測試
├── Settings/                   # 專案設定檔 (如 Build Profiles)
└── WebGLTemplates/             # WebGL 模板
```

### 主要目錄與配置說明

*   **`Scripts/` 與組件定義 (Assembly Definitions)**：
    所有 C# 程式碼的根目錄。`Runtime` 和 `Tests` 下的每個主要模組資料夾（如 `App`, `Contexts`, `Domain` 等）都配置了組件定義檔案 (`.asmdef`)。此設計旨在將程式碼分割成獨立組件，以**提升編譯速度**並實現**嚴格的模組邊界**。各組件的依賴規則將在後續章節詳述。

*   **`Settings/`**：
    包含專案級的設定檔。例如，在此配置了 **Build Profiles**，用以快速區分並切換 `debug` 與 `release` 等不同的建置環境，簡化導出流程。

*   **`WebGLTemplates/`**：
    存放 WebGL 的自訂網頁模板。本專案目前採用 [**(Unity) Better Minimal WebGL Template**](https://seansleblanc.itch.io/better-minimal-webgl-template)，以提供自適應模板。

*   **關於設定檔 (`Configs`) 的說明**：
    建議將相關的設定檔放置在最適合其功能的模組目錄下，並命名為 `Configs`（例如 `Infrastructures/Configs` 或 `Presentation/Configs`）。**`Configs` 資料夾並非固定位置**，可視專案需求在不同模組下彈性增加。

## 模組介紹

本專案採用分層架構設計，將程式碼依據其職責劃分為不同的模組（Assembly）。這種做法旨在實現**關注點分離（Separation of Concerns）**，從而提高程式碼的可維護性、可擴展性與可測試性。

最重要的規則是**單向依賴原則**：所有依賴關係都必須指向**更核心、更穩定**的模組。

### 核心模組 (Core Modules)
這些模組提供了應用程式的基礎能力與業務規則。它們通常是被動的、可重用的構建模組，由「應用模組」調用。

#### **`Domain` (領域邏輯)**
*   **職責**：包含專案最核心的業務邏輯、規則與資料結構。定義了「應用如何運作」的內核。
*   **關鍵特性**：**必須完全獨立於 Unity 引擎**。這使得核心邏輯可以脫離 Unity 環境進行快速的單元測試。
*   **依賴於**：**無**。

#### **`Services` (服務邏輯)**
*   **職責**：作為**領域邏輯**與**外部資料來源**之間的中介。負責與 `Domain` 互動或呼叫外部 API。
*   **關鍵特性**：通過介面隔離變動，使得上層應用可以輕易切換資料來源（例如，本地模式 vs. 伺服器模式）。
*   **依賴於**：`Domain`。

#### **`Presentation` (表現邏輯)**
*   **職責**：所有與 Unity 視圖渲染相關的組件（`MonoBehaviour`），負責將數據可視化並接收原始用戶輸入。
*   **關鍵特性**：遵循 **被動視圖（Passive View）** 模式，本身不包含業務判斷邏輯。它是一個被動模組，由 `App` 層驅動。
*   **依賴於**：**無**。

#### **`Infrastructures` (基礎設施)**
*   **職責**：提供與外部世界溝通的具體實現，如音效、存檔、網路請求等底層功能。
*   **關鍵特性**：功能通用且可移植。它也是一個被動模組，由 `App` 層驅動。
*   **依賴於**：**無**。



### 應用模組 (Application Module)
此模組作為應用的總指揮，主動使用「核心模組」來構建具體的應用流程與狀態管理。

#### **`App` (應用邏輯)**
應用的總指揮，是連接使用者介面、業務邏輯與底層服務的核心樞紐。它負責應用程式的**狀態管理**與**視圖邏輯**，確保數據流的清晰與一致。本模組內部採用 MVP (Model-View-Presenter) 模式的變體，職責劃分如下：

**`App/Stores/`：狀態與業務邏輯的核心**

`Store` 不僅是 MVP 中的 Model (資料容器)，更是應用程式**狀態與業務流程的發起點**。它是特定功能狀態的**單一數據源 (Single Source of Truth)**。其主要職責包括：
*   **持有狀態 (State Holding)**：管理特定功能的所有狀態（如 `IsLoading`, `UserData`）。
*   **定義操作 (Action)**：提供公開方法（如 `LoadUserDataAsync()`, `UpdateUserName()`）給 `Presenter` 呼叫。
*   **呼叫服務 (Calling Services)**：在操作方法內部，主動呼叫 `Services` 層來執行實際的業務操作（如 API 請求），並根據結果更新自身狀態。
*   **暴露狀態 (Exposing State)**：透過響應式屬性 (如 R3 的 `Observable`) 將狀態暴露出去，供 `Presenter` 訂閱。

**`App/Presenters/`：視圖的橋樑與協調者**

`Presenter` 主要作為視圖 (`Presentation`) 與狀態 (`Stores`) 之間的**橋樑**，同時也負責協調**純表現層的效果**。其主要職責包括：
*   **轉發使用者輸入**：監聽 `Presentation` 層的 UI 事件（如按鈕點擊），並呼叫 `Store` 對應的操作方法來觸發**業務邏輯**。
*   **訂閱狀態變化**：訂閱 `Store` 暴露出的狀態，並在狀態變化時，去更新 `Presentation` 層的顯示（如顯示/隱藏讀取圖示、更新文字）。
*   **協調表現層效果**：對於**不影響核心業務狀態**的即時反饋，`Presenter` 可以**直接依賴並呼叫 `Infrastructures`**。例如，點擊按鈕時立即播放音效 (`AudioPlayer`) 或觸發震動。

**核心原則**：
*   業務邏輯**必須**通過 `Store` 處理。
*   `Presenter` **絕不能**直接引用 `Services`。

**依賴關係**：
*   `Stores` 依賴於 `Services`。
*   `Presenters` 依賴於 `Stores`、`Presentation`，並可選擇性地依賴 `Infrastructures`。


### 支援模組 (Support Modules)
以下模組不直接實現功能，但為整個專案提供必要的橫向支援。

#### **`Shared` (共享)**
*   **職責**：存放需要被多個模組共用的**極少量**、**極穩定**的程式碼（如 DTOs、常數）。
*   **使用原則**：在本架構中，`Shared` 被視為一種**例外情況，而非預設選項**。**原則上，所有其他模組都應盡力避免依賴它**，以防止其演變成一個難以管理的「大雜燴」模組。
*   **依賴於**：**無**。

#### **`Contexts` (依賴注入)**
*   **職責**：負責依賴注入（DI）容器的設定與初始化。在應用啟動時，將各模組的實例創建並組裝起來。
*   **關鍵特性**：它是整個應用的「組裝工廠」，擁有上帝視角，因此需要引用它所要組裝的所有模組。
*   **依賴於**：所有需要被注入的模組（如 `App`, `Services`, `Infrastructures` 等）。

## 架構決策與設計原則 (深入探討)

一套好的架構，不僅在於其結構，更在於其背後的設計哲學。本架構採納了一系列經過驗證的軟體工程原則，以確保專案的長期健康。

本章節將對這些核心原則進行簡要概述。每個原則都有更詳細的獨立文章進行深入探討，強烈建議閱讀以充分理解其設計意圖。

### **依賴注入 (Dependency Injection, DI)**
*   **摘要**：透過 DI 來管理模組間的依賴關係，以達成松耦合與高可測試性。這是一種比 Singleton 更穩健、更可維護的模式。
*   **[深入閱讀](./Extras/dependency-injection.md)**

### **單一數據源 (Single Source of Truth, SSoT)**
*   **摘要**：應用程式中的任何一份核心數據，都應只有一個權威的來源（通常由 `Services` 層管理），以從根本上杜絕數據不一致的問題。
*   **[深入閱讀](./Extras/single-source-of-truth.md)**

### **組合優於繼承 (Composition over Inheritance)**
*   **摘要**：傾向於使用小的、功能單一的組件來構建複雜的物件，而非建立龐大僵硬的繼承樹。這提供了更大的靈活性。
*   **[深入閱讀](./Extras/composition-over-inheritance.md)**

### **MVP (Model-View-Presenter)**
*   **摘要**：本架構在 `App` 層內部採納 MVP 模式，將應用程式的邏輯、視圖和行為明確分離。這是一種**相對直覺且簡單易於實現單一職責（Single Responsibility Principle）的模式**。
*   **[深入閱讀](./Extras/mvp-simple-is-best.md)** *

### **事件佇列 (Event Queue)**
*   **摘要**：對於需要按順序播放動畫或演出的複雜流程，採用事件佇列（Event Queue）而非傳統的即時事件廣播。
*   **[深入閱讀](./Extras/event-queue-decoupling-timing.md)**

### **善用 `sealed` 與 `internal`**
*   **摘要**：這兩個 C# 關鍵字是強制執行架構邊界、明確設計意圖的利器，有助於在編譯期就發現潛在的架構問題。
*   **[深入閱讀](./Extras/sealed-and-internal.md)**

### **優先考慮「可尋性」與「易重構性」**
*   **摘要**：相對於教條式地遵守所有設計原則（如開閉原則），本指南更務實地將「快速定位修改點」作為首要目標，以適應前端專案快速迭代的特性。
*   **[深入閱讀](./Extras/pragmatism-over-dogma.md)**