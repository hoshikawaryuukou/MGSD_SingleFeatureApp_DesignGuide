# 單一數據源 (Single Source of Truth, SSoT)

## 是什麼

一個核心原則，指對於應用程式中**任何一份運行時的狀態**（例如玩家當前的生命值、背包裡的物品），都應該只有一個權威的、可信的「來源」。任何需要這份數據的模組都只能從這個來源讀取，任何修改也必須通過這個唯一的來源進行。

## 為何選用

*   **數據一致性**：這是解決「狀態同步噩夢」的終極武器。當多個地方都能修改同一份數據時（例如 UI、遊戲邏-輯、存檔系統都各自維護了一份玩家金錢的狀態），數據不一致的 bug 就會層出不窮。SSoT 從根本上杜絕了這個問題。
*   **可預測性**：數據流變得單向且清晰。當 bug 出現時，你總能快速追溯到唯一的數據源頭，而不是在數個潛在的數據副本之間猜測問題出在哪裡。

## 推薦的實踐

我們的單一數據源模式，其核心是位於 **`App` 層的 `Stores`**。整個狀態管理的生命週期都圍繞它展開。

1.  **`App/Stores`：主動的狀態管理者**
    `Stores`（例如 `PlayerStore`, `InventoryStore`）是應用程式運行期間，**唯一可信的狀態副本**。它們不僅持有數據，還封裝了圍繞這些數據的業務邏輯。
    *   **主動獲取與更新**：`Store` 自身**依賴於 `Services`**。當需要與外部世界交互時（例如，應用啟動時加載數據，或執行一個需要後端驗證的操作），`Store` 會**主動調用** `Service` 的方法（如 `_userService.LoadProfile()`），並使用返回的數據來更新自己的內部狀態。
    *   **發布變更**：當內部狀態發生變化時，`Store` 會通過**通知機制**（如響應式數據流或事件總線）將變更廣播出去，讓應用程式的其他部分可以響應這些變化。

2.  **`Services` 層：被動的數據提供者**
    在 SSoT 的語境下，`Services` 層扮演的是一個相對被動的**數據接口**角色。它們負責處理與外部世界的具體通信細節（如讀寫文件、發送 HTTP 請求），但它們**不持有運行時狀態**，也不主動推送數據。它們像是 `Stores` 用來執行特定任務的可靠工具，等待被調用，執行任務，然後返回結果。

這種架構確保了所有狀態的變更都集中在 `Stores` 中進行。一個 `Store` 負責協調整個流程：接收業務請求，必要時通過 `Service` 獲取數據，更新自己的權威狀態，最後通知外界變更已發生。這使得 `Stores` 成為了我們應用程式狀態的絕對中心。
