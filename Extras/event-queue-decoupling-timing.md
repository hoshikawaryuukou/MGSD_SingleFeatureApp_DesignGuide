# 事件佇列：解耦邏輯與表演的時序

## 是什麼
事件佇列（Event Queue）是一種設計模式，它將需要**按順序執行的任務**（特別是視覺表演指令），放入一個先進先出（FIFO）的列表中。然後由一個專門的處理器，在適當的時機，**一次一個**地從列表中取出並執行任務。

這個模式的核心目標是將**邏輯執行的時序**與**視覺表演的時序**進行解耦，從而實現對一系列視覺演出的順序與節奏的控制。

## 為何選用
在我們的專案中，選用事件佇列是出於一個務實的設計考量：我們需要**有序地呈現**一系列的業務結果。

當一次邏輯操作（如攻擊結算）觸發了多個視覺效果（動畫、音效、傷害數字）時，若沒有統一的時序控制，它們會傾向於同時開始，造成視覺混亂。更重要的是，這會迫使表演組件之間產生複雜的依賴關係，例如「A 動畫必須等待 B 特效播放完畢」，導致程式碼難以維護。

事件佇列通過**集中管理時序**的方式，為這個問題提供了一個結構化的解決方案：

1.  **確保演出順序 (Ensuring Performance Order)**
    *   它提供了一個集中的機制來編排視覺效果的播放順序。邏輯層只需關心「需要播放什麼」，而佇列則負責「何時播放」。

2.  **簡化表演組件 (Simplifying Presentation Components)**
    *   表演組件的職責被簡化為「執行收到的指令」。它們不再需要互相感知或等待，相關的流程控制都交給了佇列處理器，這**降低了**組件間的耦合。

3.  **維護狀態一致性 (Maintaining State Consistency)**
    *   核心狀態在邏輯層被一次性更新。佇列中的事件只是對這次「已完成的狀態變更」的視覺化重現。這有助於避免在表演過程中，核心狀態與視覺表現不一致的問題。

4.  **易於除錯與追蹤 (Easier Debugging & Tracing)**
    *   當演出順序有誤時，佇列本身就是一個清晰的執行記錄。我們可以檢查佇列中的事件序列來輔助定位問題的根源。

好的，這個要求非常具體，核心是闡述**序列的消耗方式**，而不是籠統地描述生產者/消費者。你提出了兩種非常經典的模式：一種是主動推送（Push），另一種是主動拉取（Pull）。

這是一個非常好的簡化方向，它讓實踐部分更聚焦於架構的決策點。

我將完全按照你的思路來重寫這一部分。

## 推薦的實踐

在我們的架構中，當 `Store` 中的狀態經過一次原子性更新後，會生成一個對應的**「表演序列」 (Performance Sequence)**。這個序列本質上就是一個包含了所有待執行視覺指令的佇列。

關鍵的設計決策點在於**如何消耗這個序列**。我們主要探討兩種模式：

### 模式一：由 Store 主導的推送模式 (Push)

這是一種由數據源（`Store`）主動驅動表演流程的模式。

1.  `Store` 在內部持有並管理生成的表演序列。
2.  `Store` 會取出序列中的**第一個**表演指令，並通過事件總線（如 MessagePipe 的 `async` Pub/Sub 機制）將其**異步發布**出去。
3.  一個或多個 `Presenter` 訂閱了自己感興趣的指令類型。收到指令後，它們開始執行對應的視覺表演（例如播放動畫），這是一個 `async` 過程。
4.  `Store` 會 `await` 這次異步發布。事件總線的機制會確保**直到所有訂閱此指令的 `Presenter` 都完成了它們的異步表演任務後**，`await` 才會結束。
5.  `Store` 隨後繼續取出序列中的**下一個**指令並發布，重複此過程，直到整個序列消耗完畢。

**優點**：流程控制的邏輯集中在 `Store` 中，`Presenter` 的職責極其單純（被動接收並執行）。

### 模式二：由 Presenter/處理器主導的拉取模式 (Pull)

這是一種由表現層（`Presenter` 或一個中央處理器）主動請求下一個表演項目的模式。

1.  `Store` 生成表演序列後，將其存放在一個可供外部訪問的佇列中，然後 `Store` 的任務便完成了。
2.  一個中央的 `QueueProcessor`（或者某個 `Presenter` 在完成任務後）會主動向這個佇列 **請求（拉取）** 下一個表演指令。
3.  `QueueProcessor` 根據指令內容，調度對應的 `Presenter` 執行表演。
4.  當表演完成後，`QueueProcessor` 再次去佇列中拉取下一個指令，周而復始。

**優點**：邏輯層與表現層的職責分離得更徹底。`Store` 完全不關心表演如何進行，只負責生成數據。
