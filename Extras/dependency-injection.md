# 依賴注入 (Dependency Injection, DI)

## 是什麼

依賴注入（DI）的核心思想非常簡單：**一個物件不應自己創建它所依賴的物件，而應由外部的「容器」或「工廠」將依賴項「注入」（傳遞）給它。**

這就像組裝電腦，CPU 不需要自己去製造主機板或記憶體；它只需要有對應的插槽，由「組裝者」（也就是我們）將合適的零件插上去即可。

## 為何我優先選擇 DI，而非 Singleton？

在討論 DI 之前，我們需要客觀看待 `Singleton` 模式。對於小型專案或真正全局唯一的服務（如音效管理器），Singleton 因其簡單直接，無疑是一種快速有效的解決方案。

然而，這份指南之所以優先選擇 DI，是基於對專案**長期健康度**與**可擴展性**的考量。當專案體量增長時，Singleton 模式的一些固有特性，可能會逐漸成為維護的痛點。DI 則提供了一套更穩健的替代方案。

以下是我們權衡的幾個關鍵點：

#### 1. 依賴的清晰度：依賴是「公開的合約」還是「隱藏的細節」？

*   **使用 DI**，一個類別的所有必要依賴都清晰地定義在其**建構子**中。這就像一份公開的「需求清單」，任何人都能一眼看出這個物件需要什麼才能正常運作。
*   **使用 Singleton**，依賴關係被隱藏在方法內部 (`SomeManager.Instance.DoSomething()`)。這使得我們難以快速了解一個類別到底與多少個全局單例產生了關聯，增加了理解和重構的難度。

#### 2. 耦合的靈活性：是「寫死的綁定」還是「可替換的插槽」？

*   **使用 DI**，物件只依賴於一個**抽象**（例如 `IStorage` 介面）或一個**可被替換的具-體類**。這種設計提供了多層次的靈活性：
    *   **元件級替換**：我們可以輕易地在不同情境下更換單個元件的實現，例如，將本地存檔 `LocalSaveSystem` 切換為雲端存檔 `CloudSaveSystem`，而無需修改使用方的程式碼。
    *   **容器級替換**：我們甚至可以為不同環境（如開發、測試、生產）準備**完全不同的 DI 容器配置**。例如，開發時注入的是連線到本地資料庫的服務，而生產環境則注入連線到線上資料庫的服務。這種切換是全局性的，讓整個應用能無縫適應不同場景。
*   **使用 Singleton**，程式碼直接與一個**具體的靜態實例** (`GameManager.Instance`) 綁定。這種緊耦合關係是寫死的，無論是想替換單個元件還是整套配置，都會變得非常困難且容易出錯。

#### 3. 可測試性：是「輕鬆模擬」還是「困難重重」？

*   **這也許是 DI 最重要的優勢。** 在進行單元測試時，我們可以輕易地創建一個「假的」依賴項（Mock Object）並將其注入到待測物件中，從而實現對核心邏輯的隔離測試。
*   **Singleton 則讓隔離測試變得極其困難**，因為我們無法輕易地替換掉那個全局唯一的實例，導致測試常常需要啟動大量不相關的系統，變得緩慢且不可靠。

**總結來說，Singleton 提供的是「便利性」，而 DI 提供的是「穩健性」與「靈活性」。** 對於追求高品質、易於維護和測試的架構來說，DI 是更優越的選擇。

## 推薦的實踐

### 1. 優先選用建構子注入 (Constructor Injection)

*   **保證有效狀態**：一旦物件被創建出來，它所有必需的依賴都已就位，可以立刻進入有效的工作狀態。
*   **依賴清晰化**：建構子就是一份「依賴清單」，任何人都無法創建一個「缺少零件」的物件。
*   **不變性 (Immutability)**：可以將依賴項儲存在 `readonly` 欄位中，防止在物件的生命週期內被意外篡改。

### 2. 抽象是「需求」，而非「必須」

*   當一個依賴**預期會有多種實現方式**時（例如，`ILocalSaveSystem` vs `ICloudSaveSystem`），我們才為它建立抽象（介面）。
*   如果一個類在可預見的未來**只有一種實現**，直接注入這個**具體的類**是完全可以接受且更簡單的做法。DI 的核心是「控制反轉」，即使注入的是具體類，這個核心優勢依然存在。

### 3. `Contexts` 模組作為我們的「組裝工廠」

`Contexts` 模組是整個 DI 機制的啟動點。它負責在應用啟動時：
1.  創建所需的實例。
2.  解析它們之間的依賴關係。
3.  將它們「組裝」在一起，完成注入。
