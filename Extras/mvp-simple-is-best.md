# MVP 模式：大道至簡

我們的 MVP 核心理念極其簡單，只有三件事：

**畫面 (View)**、**狀態 (Store)**，以及一個把它們**綁起來 (Presenter)** 的東西。

這個架構讓我們能用最直觀的方式思考問題，摒棄一切不必要的複雜性。

## 為什麼這樣做就是最好的？

1.  **直指核心**：當你想修改功能時，思路非常清晰：
    *   想改**畫面**長相？去找 `View`。
    *   想改**資料**邏輯？去找 `Store`。
    *   想改**連動**規則？去找 `Presenter`。

2.  **單向數據流**：資料的流動永遠是可預測的。
    *   **`View` (操作) → `Presenter` (轉告) → `Store` (更新狀態) → `Presenter` (通知) → `View` (刷新畫面)**
    *   這種單純的循環讓除錯和維護變得輕而易舉。

## 三大角色，各司其職

*   ### **畫面 (View)：只管長相**
    *   它位於 `Presentation` 模組。
    *   它很「笨」，只負責兩件事：顯示資料（如更新血條），和回報使用者操作（如「按鈕被點了」）。
    *   它不認識 `Store` 或 `Presenter`，完全被動。

*   ### **狀態 (Store)：唯一真相**
    *   它位於 `App/Stores` 模組。
    *   它是應用的「單一數據源 (Single Source of Truth)」，管理著像 `IsLoading`、`CurrentUserData` 這類狀態。
    *   所有狀態的變更都必須透過它提供的公開方法來完成，確保狀態變更是可控的。
    *   當需要執行複雜的業務邏輯時，它會委託給 `Services` 處理，再將結果更新回自身。

*   ### **綁定器 (Presenter)：膠水和翻譯官**
    *   它位於 `App/Presenters` 模組。
    *   它的工作就是把「畫面」和「狀態」綁在一起，是整個模式的靈魂。
    *   **職責一：翻譯操作**
        *   從 `View` 接收操作信號（例如：「購買按鈕被點擊」）。
        *   將其「翻譯」成對 `Store` 的請求（例如：呼叫 `Store.PurchaseItem()`）。
    *   **職責二：同步狀態**
        *   訂閱 `Store` 的狀態變化（例如：`Store.OnItemChanged`）。
        *   當狀態改變時，通知 `View` 更新對應的顯示（例如：呼叫 `View.UpdateItemCount(5)`）。
