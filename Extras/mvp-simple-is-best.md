# MVP 模式：大道至簡

我們的 MVP (Model-View-Presenter) 核心理念極其簡單，只有三件事：

**畫面 (View)**、**狀態 (Store)**，以及一個把它們**橋接起來 (Presenter)** 的東西。

這個架構讓我們能用最直觀的方式思考 UI 與邏輯的互動，摒棄一切不必要的複雜性。

## 為何這樣做就是最好的？

1.  **直指核心，職責清晰**：當你想修改一個功能時，思路永遠清晰：
    - 想改**畫面外觀或佈局**？去找 `View` (`Presentation` 模組)。
    - 想改**業務處理流程**？去找 `UseCase` (`Application` 模組)。
    - 想改**UI 如何響應狀態變化**？去找 `Presenter` (`Presenters` 模組)。
    - 想知道**當前狀態**是什麼？去看 `Store` (`Application` 模組)。

2.  **可預測的單向數據流**：數據的流動永遠是可預測的循環，讓除錯和維護變得輕而易舉。
    - `View` (用戶操作) → `Presenter` (轉譯意圖，呼叫 UseCase) → `UseCase` (執行業務邏輯) → `Store` (更新狀態) → `Presenter` (監聽變化) → `View` (刷新畫面)。

## 三大角色，各司其職

- ### **畫面 (View)：純粹的視覺**
  - **位置**：`Presentation` 模組。
  - **職責**：它很「笨」，只負責兩件事：**顯示數據**（如更新血條），和**轉發用戶輸入**（如廣播「按鈕被點擊了」的事件）。
  - **原則**：它不包含任何判斷或業務邏輯。它不認識 `UseCase` 或 `Store`，完全是被動的。

- ### **狀態 (Store)：權威的狀態容器**
  - **位置**：`Application/Stores` 模組。
  - **職責**：它是應用的**單一數據源 (SSoT)**，作為特定領域狀態（如 `IsLoading`, `CurrentUserData`）的唯一、權威的容器。
  - **原則**：`Store` 本身是**被動的**。它的寫入權限被 `internal` 保護，**只有 `UseCase` 才能修改它**。它通過唯讀的響應式屬性將狀態暴露出去，供外界訂閱。

- ### **橋接器 (Presenter)：膠水與協調者**
  - **位置**：`Presenters` 模組。
  - **職責**：它的工作就是把「畫面 (View)」和「核心 (`Application`)」綁在一起，是整個模式的靈魂。

    #### 職責一：轉譯用戶操作
    - 它監聽 `View` 發出的用戶操作信號（例如：「購買按鈕被點擊」）。
    - 它將這個操作「轉譯」成一個業務請求，並**呼叫對應的 `UseCase`**（例如：`_purchaseItemUseCase.ExecuteAsync(itemId)`）。Presenter 只關心 **「用戶想做什麼」** ，而不關心 **「具體是怎麼做的」** 。

    #### 職責二：同步 UI 狀態
    - 它訂閱 `Store` 中的狀態變化（例如：`playerStore.Health`）。
    - 當狀態改變時，它負責將核心層的數據**轉換為適合 `View` 顯示的格式**，然後驅動 `View` 更新對應的顯示（例如：呼叫 `view.SetHealthBar(0.8f)`）。