# Unity 小遊戲專案架構指導原則

這份文件旨在總結一套適用於 Unity 中小型遊戲專案的現代化、可維護、可擴展的架構設計原則。其核心思想是借鑒軟體工程中的成熟模式，並根據 Unity 遊戲開發的特性進行務實的調整。

## 核心理念

此架構建立在幾個關鍵的設計模式和原則之上，它們相輔相成，構成一個完整且健壯的系統：

- **分層架構 (Clean Architecture)**：分離關注點，隔離變化。
- **MVP 模式 (Model-View-Presenter)**：作為 UI 與邏輯互動的核心骨架。
- **單一數據源 (Single Source of Truth)**：集中管理狀態，使數據流可預測。
- **事件佇列 (Event Queue)**：解耦邏輯執行與視覺表現的時序。
- **依賴注入 (Dependency Injection)**：管理依賴關係與物件的生命週期。
- **務實的設計哲學**：在理論與實踐中取得平衡。

---

## 原則一：分層架構－關注點分離

將專案程式碼明確劃分為三個主要層次，並嚴格遵守單向依賴原則。`App` 層是整個架構的中心協調者。

- **依賴方向**:
  - `App` → `Domain`
  - `App` → `Presentation`

```
┌────────────────┐   ┌────────────────┐   ┌────────────────┐
│ Presentation   │ ← │      App       │ → │     Domain     │
│ (被動視圖)     │   │ (主動協調者)   │   │ (核心模型)     │
└────────────────┘   └────────────────┘   └────────────────┘
```

1.  **`Domain` (核心模型層):**
    *   **職責**: 包含遊戲最核心的規則、數據結構和業務邏輯。
    *   **特點**: 完全獨立，不包含任何對 `App` 或 `Presentation` 的引用。這使得它可以被獨立測試，甚至移植。
    *   **範例**: `Game` 類別、棋盤數據、勝負判斷邏輯 (`WinChecker`)。

2.  **`Presentation` (表現層):**
    *   **職責**: 所有與 Unity 引擎直接相關的視覺和互動組件。
    *   **特點**: 作為「被動視圖」，僅負責呈現數據和捕獲最原始的用戶輸入（如點擊），並將操作通知給 `App` 層。它不了解 `Domain` 的存在。
    *   **範例**: `GameStageView`, `CellView`, `GameMenuView` 等 `MonoBehaviour` 組件。

3.  **`App` (應用/協調層):**
    *   **職責**: 作為 `Domain` 和 `Presentation` 之間的協調者。它承載了應用程式的流程控制。
    *   **特點**: 持有 `Domain` (通常透過 Store) 和 `Presentation` (View) 的引用，負責響應使用者操作、調用核心邏輯、管理狀態並最終驅動視圖更新。

---

## 原則二：狀態管理－單一數據源 (Store)

借鑒前端開發思想，將共享狀態集中在 `Store` 物件中，作為唯一的數據來源。

1.  **集中化**: 避免將狀態散落在各個 `MonoBehaviour` 中。建立如 `GamePlayStore`（管理核心玩法狀態）和 `GameUIStore`（管理UI狀態）的類別。
2.  **單向數據流**:
    *   **Action**: `View` 發出用戶操作。
    *   **State Change**: `Presenter` 調用 `Store` 的方法來請求變更狀態。
    *   **Reaction**: `View` 或 `Presenter` 訂閱 `Store` 的狀態變化（推薦使用 `R3` 等響應式框架），並在狀態更新時自動刷新自己。
3.  **好處**: 數據流變得清晰可預測，極大簡化了除錯過程，也為未來的功能（如存檔、重播）打下良好基礎。

---

## 原則三：MVP 模式作為核心骨架

將分層架構對應到熟悉的 MVP 模式，可以讓職責劃分更加清晰。

-   **Model**: `Domain` 層的業務物件 + `App` 層的 `Store`。
-   **View**: `Presentation` 層的 `MonoBehaviour` 組件。
-   **Presenter**: `App` 層的 `Presenter` 類別。

Presenter 作為中間人，從 Model 獲取數據並更新 View，同時處理來自 View 的事件。

---

## 原則四：事件佇列－解耦時序

對於需要按順序播放動畫或演出的複雜流程，使用事件佇列（Event Queue）而非傳統的即時事件廣播。

1.  **劇本生成**: 邏輯層（如 `Store`）在一次操作中，將所有後續需要「表演」的事件，按順序放入一個佇列中。
2.  **導演播放**: 表演層的控制器（如 `GameStagePresenter`）從佇列中逐一取出事件，並等待每個事件對應的動畫或演出完成後 (`await`)，再處理下一個事件。
3.  **好處**:
    *   完美分離了「邏輯發生的速度」和「視覺表演的速度」。
    *   讓表演組件的職責更單純，只需專注於「播放」。
    *   非常適合回合制、卡牌、棋盤或有複雜演出序列的遊戲。

---

## 原則五：依賴注入－管理生命週期與依賴

使用依賴注入（DI）框架（如 `VContainer`）來自動化物件的創建和依賴關係的注入。

1.  **解耦**: 類別不再需要手動 `new` 或 `GetComponent` 來獲取其依賴，而是透過構造函數聲明其需求，由 DI 容器負責滿足。
2.  **生命週期管理**: 利用 DI 容器的 `LifetimeScope`（可稱之為 `Context`）來管理物件的生命週期。當 Scope 結束時（如場景卸載），所有相關物件會被自動清理 (`Dispose`)，有效防止記憶體和訂閱洩漏。
3.  **可擴展性**: 透過劃分不同的 `Context`（如 `ProjectContext`, `SceneContext`）來管理不同生命週期的物件，使專案易於擴展。

---

## 原則六：務實的設計哲學

設計原則是指導方針，而非必須嚴格遵守的教條。應根據專案的實際情況進行權衡。

1.  **組合優於繼承**: 盡可能使用組合來擴展功能，而不是繼承。並使用 `sealed` 關鍵字來明確標示一個類別不應被繼承，這能強化設計意圖並帶來潛在的效能優化。
2.  **務實的抽象**:
    *   **不過度使用介面**: 不需要為每一個類別都創建介面。只在真正需要「抽象」的地方使用它（例如 `Domain` 與 `App` 的邊界，或預期會有多种實現的功能）。
    *   **可讀性優先**: 對於像 `View` 這樣與 `Prefab` 強綁定的具體類別，直接依賴通常比引入一個不必要的介面更清晰、更易於導航。
    *   **定位效率 > OCP**: 在很多情況下，「當需求變更時，能快速找到並修改對應程式碼」的價值，高於為了遵守「開放封閉原則」而建立的複雜抽象層。
3.  **專注高回報的測試**:
    *   將自動化測試的精力主要集中在 `Domain` 層。
    *   這一層的邏輯最核心、最複雜，也最容易進行單元測試，測試的回報率最高。
    *   對於 `Presentation` 層，手動測試通常是更有效率的選擇。